module src/test

import test
import src/game
import src/solver

def simpleBoard1() = buildBoard(5, 5, Cons(XY(2,2),Cons(XY(4,4),Nil())))
def simpleBoard2(): Board = {
  var board = buildBoard(3, 3, Cons(XY(0,0),Nil()))
  try {board.revealCell(XY(1,1))}
  with GameOver {board}
}

/**
F 2 F
2 4 2
? ? ?
**/
def complexBoard1() = {
  var board = buildBoard(3, 3, Cons(XY(0,0),Cons(XY(2,0),Cons(XY(0,2),Cons(XY(2,2),Nil())))))
  try {
    board.revealCell(XY(0,1))
    board.revealCell(XY(1,0))
    board.revealCell(XY(1,1))
    board.revealCell(XY(2,1))
  }
  with GameOver {board}
}

/**
? ? ? ? ? ?
F 2 2 2 2 ?
1 1 0 0 2 ?
0 0 0 0 1 ?
**/
def complexBoard2() = {
  var board = buildBoard(4, 6, Cons(XY(0,1),Cons(XY(2,0),Cons(XY(3,0),Cons(XY(5,1),Cons(XY(5,3),Nil()))))))
  try {board.revealCell(XY(0,3))}
  with GameOver {board}
}

// ----------------------------- GAME ---------------------------
def testFlagCell() = {
  val board = simpleBoard1()
  val xy = XY(1,1)
  val updatedBoard = flagCell(board, xy)
  do assert(equals(updatedBoard.getCell(xy), Hidden(false,true)), "Flagging failed")
  val toggledBoard = flagCell(updatedBoard, xy)
  do assert(equals(toggledBoard.getCell(xy), Hidden(false,false)), "Removing flag failed")
}

def testRevealCell() = {
  val board = simpleBoard1()
  try {
    val revealedBoard = revealCell(board, XY(0, 0))
    do assert(revealedBoard.getCell(XY(0, 0)) match {
      case Revealed(_) => true
      case _           => false
    }, "Reveal failed")
    revealCell(board, XY(2, 2))
    do assert(false, "Reveal failed to trigger GameOver for mine")
  } with GameOver {
    println("GameOver correctly triggered")
  }
}

def testCountAdjacentMines() = {
  val board = simpleBoard1()
  val count = countAdjacentMines(board, XY(3, 3))
  do assert(count == 2, "Incorrect adjacent mine count")
}

def testCollectWithXY() = {
  val board = simpleBoard1()
  val collectedCells = collectWithXY(board) {
    case Hidden(true, _) => true
    case _               => false
  }
  val res = collectedCells.all() {
    case (XY(2,2),Hidden(true,false)) => true
    case (XY(4,4),Hidden(true,false)) => true
    case _ => false
  }
  do assert(res, "collectWithXY failed to collect the correct cells")
}

// ---------------------- SOLVER -----------------------------
def testSolve() = {
  val board = simpleBoard2()
  var moves: List[XY] = empty()
  try {
    moves = board.getMoves()
    ()
  }
  with QuickMoves {_ => ()}
  do assert(moves.size == 0, "Solver should return no moves")
}

def testUnrevealedNeighbors() = {
  val board = simpleBoard2()
  val neighbors = unrevealedNeighbors(board, XY(1, 1))
  do assert(neighbors.size == 8, "Should find 8 unrevealed neighbors for (1, 1)")
  do assert(neighbors.any{xy => xy == XY(0, 0)}, "Should include top-left neighbor")
  do assert(neighbors.any{xy => xy == XY(2, 2)}, "Should include bottom-right neighbor")
}

def testRemoveMine() = {
  var board = simpleBoard2()
  board.removeMine(XY(0, 0))
  do assert(board.getCell(XY(0, 0)) == Revealed(0), "Bomb revealed")
  do assert(board.getCell(XY(0, 1)) == Hidden(false, false), "Hidden cells stay hidden")
  do assert(board.getCell(XY(1, 1)) == Revealed(0), "Should update mine count in neighbors")
}

def testSolverSimple() = {
  val board = simpleBoard1()
  do assert(0 == 1, "todo")
}

def testSolverComplex() = {
  val board = complexBoard1()
  var moves: List[XY] = empty()
  try {
    moves = board.getMoves()
    ()
  }
  with QuickMoves {_ => ()}
  println(moves.size.show)
  do assert(moves.size == 1, "One possible move")
  do assert(moves.any{xy => xy == XY(1,2)}, "The move should be (1,2)")
}

def runTests() = {
  println("Running tests...")
  suite("Fairsweeper Game") {
    test("FlagCell"){testFlagCell()}
    test("RevealCell"){testRevealCell()}
    test("AdjacentMines"){testCountAdjacentMines()}
    test("CollectCells"){testCollectWithXY()}
    }
  suite("Solver") {
    test("NoSureMove"){testSolve()}
    test("UnrevealedNeighbors"){testUnrevealedNeighbors()}
    test("RemoveMine"){testRemoveMine()}
    test("Solve complex map 1"){testSolverComplex()}
  }
  println("All tests passed!")
}

def main() = runTests()
