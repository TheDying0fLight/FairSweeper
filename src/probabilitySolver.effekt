module src/probabilitySolver

import src/board
import src/utils
import src/main
import src/solver

effect QuantumMine(): Bool

def getProbabilities(board: Board): List[(XY,Double)] = {
  with on[OutOfBounds].panic
  var curBoard = board.copy
  curBoard.hideHiddenInfo
  val obvsMines = curBoard.revealObviousMines
  val numbers = curBoard.getRevealed
  val hidden = curBoard.getXY{
    case SHidden() => true
    case _ => false
  }
  val par = hidden.partition{ xy =>
    curBoard.getRevealedNeighbors(xy).size > 0
  }
  // sort by amount of revealed neighbors / information
  val hiddenNearNumber = par.first.sortBy{ (xy, xy2) =>
    curBoard.getRevealedNeighbors(xy).size > curBoard.getRevealedNeighbors(xy2).size
  }
  val showBoard = curBoard.copy
  hiddenNearNumber.foreach{xy => showBoard.setCell(xy, Relevant())}
  // println(board)
  println(showBoard)
  println("Relevant Fields: " ++ hiddenNearNumber.size.show ++ ", Possible Boards: " ++ 2.0.pow(hiddenNearNumber.size).show)
  val hiddenAway = par.second
  val hiddenAwaySize = hiddenAway.size
  val minMines = curBoard.mines - hiddenAwaySize
  val counts = array(hiddenNearNumber.size, bigInt(0))
  var hiddenAwayCount = bigInt(0)
  var boardAmount = bigInt(0)
  var foundBoards = 0
  try {
    var curBoard = curBoard
    var mines = array(hiddenNearNumber.size, false)
    var valid = true
    var mineAmt = obvsMines.size
    hiddenNearNumber.foreachIndex{ (idx,xy){ctrl} =>
      if (do QuantumMine()) {
        curBoard = curBoard.copy
        valid = curBoard.removeMine(xy)
        mines = mines.copy
        mines.set(idx, true)
        mineAmt = mineAmt + 1
      }
      else {
        curBoard = curBoard.copy
        valid = curBoard.removeMove(xy)
      }
      // count mines instead of always calc size when leak is fixed
      valid = valid && mineAmt <= board.mines
      if (not(valid)) ctrl.break
    }
    if (valid && mineAmt >= minMines) {
      // println("-----------")
      // println(curBoard)
      foundBoards = foundBoards + 1
      val hiddenArrangements = binApprox(hiddenAwaySize, board.mines - mineAmt).floor
      boardAmount = boardAmount + bigInt(hiddenArrangements)
      hiddenAwayCount = hiddenAwayCount + bigInt(hiddenArrangements) * bigInt((board.mines - mineAmt))
      mines.foreachIndex{ (idx,hasMine) =>
        if (hasMine) counts.set(idx, counts.get(idx) + bigInt(hiddenArrangements))
      }
    }
  } with QuantumMine {
    resume(false)
    resume(true)
  }
  var probs = empty()
  hiddenNearNumber.foreachIndex{ (idx,xy) =>
    probs = probs.append([(xy,(counts.get(idx).toDouble/boardAmount.toDouble))])
  }
  val awayProb = (hiddenAwayCount.toDouble/boardAmount.toDouble)/hiddenAwaySize.toDouble
  hiddenAway.foreach{ xy => probs = probs.append([(xy,awayProb)])}
  obvsMines.foreach{ xy => probs = probs.append([(xy, 1.0)])}
  println("Found Boards: " ++ foundBoards.show ++ ", " ++ "Valid Boards: " ++ boardAmount.show)
  // println(awayProb)
  // println(hiddenAwayCount.toDouble)
  // println(boardAmount.toDouble)
  // println(hiddenAwaySize.toDouble)
  probs
}

def revealObviousMines(board: Board): List[XY] =
  board.getRevealed.collect{ xy =>
    board.getCell(xy) match {
      case SRevealed(c,_) =>
        val hdnbs = board.getHiddenNeighbors(xy)
        if (hdnbs.size == c)
          Some(hdnbs.collect{xy2 => board.removeMine(xy2); Some(xy2)})
        else None()
      case _ => None()
    }
  }.flatMap{e => e}