module src/probabilitySolver

import src/game
import src/utils
import src/main
import src/solver

effect QuantumMine(xy: XY, board: Board): Board

def getProbabilities(board: Board): List[(XY,Double)] = {
  val board = board.copy
  board.hideHiddenInfo
  val hidden = board.getXY{
    case TrueHidden() => true
    case _ => false
  }
  val par = hidden.partition{ xy =>
    board.getRevealedNeighbors(xy).size > 0
  }
  val hiddenNearNumber = par.first
  val hiddenAway = par.second
  val minMines = board.mines - hiddenAway.size
  println(hiddenNearNumber)
  var hiddenAwayCount = 0
  var counts = CellDict(Nil())
  var probs: List[(XY,Double)] = empty()
  // maybe calculate k over n for hiddenAway and give each mine that value
  var validBoards: List[List[XY]] = empty()
  try {
    var curBoard = board.copy
    var valid = true
    hiddenNearNumber.foreach{ (xy){ctrl} =>
      curBoard = do QuantumMine(xy, curBoard)
      valid = curBoard.isValid(xy, minMines)
      if (not(valid)) ctrl.break
    }
    if (valid) {
      validBoards = validBoards.append([curBoard.getMines])
    }
  } with QuantumMine { (xy, board) =>
    board.setCell(xy, Mine())
    resume(board.copy)
    board.setCell(xy, NoMine())
    resume(board)
  }
  validBoards.foreach{ posbMines =>
    val part = posbMines.partition{ mine =>
      hiddenNearNumber.any{ xy => mine == xy}
    }
    hiddenAwayCount = hiddenAwayCount + part.second.size
    part.first.foreach{ xy =>
      counts = counts.set(xy, counts.get(xy) + 1)
    }
  }
  var boardAmount = 0
  boardAmount = validBoards.size
  hiddenNearNumber.foreach{ xy =>
    val amt = counts.get(xy)
    probs = probs.append([(xy,(amt.toDouble/boardAmount.toDouble))])
  }
  val awayProb = hiddenAwayCount.toDouble/boardAmount.toDouble
  hiddenAway.foreach{ xy => probs = probs.append([(xy,awayProb)])}
  probs.foreach{case (xy,prob) => println(xy.show ++ prob.show)}
  probs
}

def getMines(board: Board): List[XY] =
  board.collect{ (xy,cell) =>
    cell match {
      case Mine() => Some(xy)
      case _ => None()
    }
  }

def isValid(board: Board, xy: XY, minMines: Int): Bool = {
  board.getRevealedNeighbors(xy).all{ xy =>
    board.getCell(xy) match {
      case Revealed(c) => c >= board.mineCount(xy)
      case _ => println("How did we get here"); <>
    }
  } && minMines <= board.getMines.size
}

def mineCount(board: Board, xy: XY): Int =
  board.getNeighbors(xy, 1).collect{ xy =>
    board.getCell(xy) match {
      case Mine() => Some(true)
      case _ => None()
    }
  }.size