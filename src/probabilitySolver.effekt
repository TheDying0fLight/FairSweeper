module src/probabilitySolver

import src/board
import src/solverBoard
import src/utils
import src/main
import src/solver

effect QuantumMine(xy: XY, board: SBoard): SBoard

def getProbabilities(board: Board): List[(XY,Double)] = {
  println("-- Calculating Probability --")
  var curBoard = board.fromBoard
  curBoard.revealObviousMines
  val numbers = curBoard.getRevealed
  val hidden = curBoard.getXY{
    case -1 => true
    case _ => false
  }
  val par = hidden.partition{ xy =>
    curBoard.getRevealedNeighbors(xy).size > 0
  }
  val hiddenNearNumber = par.first
  val hiddenAway = par.second
  val minMines = curBoard.mines - hiddenAway.size
  var validBoards: List[List[XY]] = empty()
  try {
    var valid = true
    hiddenNearNumber.foreach{ (xy){ctrl} =>
      curBoard = do QuantumMine(xy, curBoard)
      valid = curBoard.isValid(xy)
      if (not(valid)) ctrl.break
    }
    if (valid && curBoard.getMines.size >= minMines) {
      if (valid) validBoards = validBoards.append([curBoard.getMines])
    }
  } with QuantumMine { (xy, board) =>
    board.setCell(xy, -2)
    resume(board.copy)
    board.setCell(xy, -3)
    resume(board)
  }
  var counts = CellDict(Nil())
  var hiddenAwayCount = 0
  validBoards.foreach{ posbMines =>
    hiddenAwayCount = hiddenAwayCount + board.mines - posbMines.size
    posbMines.foreach{ xy =>
      counts = counts.set(xy, counts.get(xy) + 1)
    }
  }
  // maybe calculate k over n for hiddenAway and give each mine that value
  val boardAmount = validBoards.size
  var probs = hiddenNearNumber.map{ xy =>
    val amt = counts.get(xy)
    (xy,(amt.toDouble/boardAmount.toDouble))
  }
  val awayProb = (hiddenAwayCount.toDouble/boardAmount.toDouble)/hiddenAway.size.toDouble
  hiddenAway.foreach{ xy => probs = probs.append([(xy,awayProb)])}
  probs
}

def revealObviousMines(board: SBoard): Unit = {
  val numbers = board.getRevealed
  numbers.foreach{ xy =>
    board.getCell(xy) match {
      case v and v >= 0 =>
        val hdnbs = board.getHiddenNeighbors(xy)
        val mines = board.getMineNeighbors(xy)
        if (hdnbs.size + mines.size == v) hdnbs.foreach{xy2 => board.setCell(xy2, -2)}
      case _ => ()
    }
  }
}