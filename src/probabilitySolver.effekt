module src/probabilitySolver

import src/game
import src/utils
import src/main
import src/solver

effect QuantumMine(xy: XY, board: Board): Board

def getProbabilities(board: Board): List[(XY,Double)] = {
  board.hideHiddenInfo
  val numbers = board.getXY{
    case Revealed(_) => true
    case _ => false
  }
  val hidden = board.getXY{
    case TrueHidden() => true
    case _ => false
  }
  val par = hidden.partition{ xy =>
    board.getRevealedNeighbors(xy).size > 0
  }
  val hiddenNearNumber = par.first
  val hiddenAway = par.second
  val minMines = board.mines - hiddenAway.size
  var hiddenAwayCount = 0
  var counts = CellDict(Nil())
  var probs: List[(XY,Double)] = empty()
  // maybe calculate k over n for hiddenAway and give each mine that value
  var validBoards: List[List[XY]] = empty()
  try {
    var curBoard = board.copy
    var valid = true
    hiddenNearNumber.foreach{ (xy){ctrl} =>
      curBoard = do QuantumMine(xy, curBoard)
      valid = curBoard.isValid(xy)
      if (not(valid)) ctrl.break
    }
    if (valid && curBoard.getMines.size >= minMines) {
      if (valid) validBoards = validBoards.append([curBoard.getMines])
    }
  } with QuantumMine { (xy, board) =>
    board.setCell(xy, Mine())
    resume(board.copy)
    board.setCell(xy, NoMine())
    resume(board)
  }
  validBoards.foreach{ posbMines =>
    hiddenAwayCount = hiddenAwayCount + board.mines - posbMines.size
    posbMines.foreach{ xy =>
      counts = counts.set(xy, counts.get(xy) + 1)
    }
  }
  var boardAmount = 0
  boardAmount = validBoards.size
  hiddenNearNumber.foreach{ xy =>
    val amt = counts.get(xy)
    probs = probs.append([(xy,(amt.toDouble/boardAmount.toDouble))])
  }
  val awayProb = (hiddenAwayCount.toDouble/boardAmount.toDouble)/hiddenAway.size.toDouble
  hiddenAway.foreach{ xy => probs = probs.append([(xy,awayProb)])}
  probs
}

def getMines(board: Board): List[XY] =
  board.collect{ (xy,cell) =>
    cell match {
      case Mine() => Some(xy)
      case _ => None()
    }
  }

def isValid(board: Board, xy: XY): Bool = {
  board.getRevealedNeighbors(xy).all{ xy =>
    val mineCheck = board.mineCount(xy)
    board.getCell(xy) match {
      case Revealed(c) => if (mineCheck.second) c == mineCheck.first else c >= mineCheck.first
      case _ => println("How did we get here"); <>
    }
  }
}

def mineCount(board: Board, xy: XY): (Int,Bool) = {
  var noTrueHiddenNbs = true
  (board.getNeighbors(xy, 1).collect{ xy =>
    board.getCell(xy) match {
      case Mine() => Some(true)
      case TrueHidden() => noTrueHiddenNbs = false; None()
      case _ => None()
    }
  }.size, noTrueHiddenNbs)
}