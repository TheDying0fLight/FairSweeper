module src/probabilitySolver

import src/board
import src/solverBoard
import src/utils
import src/main
import src/solver

effect QuantumMine(xy: XY, board: Board): Board

def getProbabilities(board: Board): List[(XY,Double)] = {
  println("-- Calculating Probability --")
  println(board)
  var curBoard = board.copy
  curBoard.hideHiddenInfo
  val numbers = curBoard.getRevealed
  val hidden = curBoard.getXY{
    case TrueHidden() => true
    case _ => false
  }
  val par = hidden.partition{ xy =>
    curBoard.getRevealedNeighbors(xy).size > 0
  }
  val hiddenNearNumber = par.first
  val hiddenAway = par.second
  val minMines = curBoard.mines - hiddenAway.size
  var depth = 0
  var counts = CellDict(Nil())
  var hiddenAwayCount = 0
  var boardAmount = 0
  try {
    var valid = true
    hiddenNearNumber.foreach{ (xy){ctrl} =>
      curBoard = do QuantumMine(xy, curBoard)
      valid = curBoard.isValid(xy)
      if (not(valid)) ctrl.break
    }
    if (valid && curBoard.getMines.size >= minMines) {
      if (valid) {
        boardAmount = boardAmount + 1
        // println(boardAmount)
        val posbMines = curBoard.getMines
        hiddenAwayCount = hiddenAwayCount + board.mines - posbMines.size
        posbMines.foreach{ xy =>
          counts = counts.set(xy, counts.get(xy) + 1)
        }
      }
    }
  } with QuantumMine { (xy, board) =>
    board.setCell(xy, NoMine())
    resume(board.copy)
    board.setCell(xy, Mine())
    resume(board)
  }
  // maybe calculate k over n for hiddenAway and give each mine that value
  var probs = hiddenNearNumber.map{ xy =>
    val amt = counts.get(xy)
    (xy,(amt.toDouble/boardAmount.toDouble))
  }
  val awayProb = (hiddenAwayCount.toDouble/boardAmount.toDouble)/hiddenAway.size.toDouble
  hiddenAway.foreach{ xy => probs = probs.append([(xy,awayProb)])}
  // println(hiddenAwayCount.toDouble)
  // println(boardAmount.toDouble)
  // println(hiddenAway.size.toDouble)
  probs
}