module src/probabilitySolver

import src/board
import src/utils
import src/main
import src/solver

effect QuantumMine(): Bool

def getProbabilities(board: Board): List[(XY,Double)] = {
  println("-- Calculating Probability --")
  // println(board)
  var curBoard = board.copy
  curBoard.hideHiddenInfo
  val obvsMines = curBoard.revealObviousMines
  val numbers = curBoard.getRevealed
  val hidden = curBoard.getXY{
    case SHidden() => true
    case _ => false
  }
  val par = hidden.partition{ xy =>
    curBoard.getRevealedNeighbors(xy).size > 0
  }
  // sort by amount of revealed neighbors / information
  val hiddenNearNumber = par.first.sortBy{ (xy, xy2) =>
    curBoard.getRevealedNeighbors(xy).size > curBoard.getRevealedNeighbors(xy2).size
  }
  val showBoard = curBoard.copy
  hiddenNearNumber.foreach{xy => showBoard.setCell(xy, Relevant())}
  println(showBoard)
  println("Relevant Fields: " ++ hiddenNearNumber.size.show ++ ", Possible Boards: " ++ 2.0.pow(hiddenNearNumber.size).show)
  val hiddenAway = par.second
  val minMines = curBoard.mines - hiddenAway.size
  var counts = CellDict(Nil(), bigInt(0))
  var hiddenAwayCount = bigInt(0)
  var boardAmount = bigInt(0)
  var foundBoards = 0
  // var mineAmt = 0
  try {
    var curBoard = curBoard
    var mines: List[XY] = obvsMines
    var valid = true
    hiddenNearNumber.foreach{ (xy){ctrl} =>
      if (do QuantumMine()) {
        curBoard = curBoard.copy
        valid = curBoard.removeMine(xy)
        mines = mines.append([xy])
      }
      else {
        curBoard = curBoard.copy
        valid = curBoard.removeMove(xy)
      }
      // count mines instead of always calc size when leak is fixed
      valid = valid && mines.size <= curBoard.mines
      if (not(valid)) ctrl.break
    }
    val mineAmt = mines.size
    if (valid && mineAmt >= minMines) {
      // println("-----------")
      // println(curBoard)
      foundBoards = foundBoards + 1
      val hiddenArrangements = binApprox(hiddenAway.size, board.mines - mineAmt).floor
      boardAmount = boardAmount + bigInt(hiddenArrangements)
      hiddenAwayCount = hiddenAwayCount + bigInt(hiddenArrangements) * bigInt((board.mines - mineAmt))
      mines.foreach{ xy =>
        counts = counts.set(xy, counts.get(xy) + bigInt(hiddenArrangements))
      }
    }
  } with QuantumMine {
    resume(false)
    resume(true)
  }
  var probs = hiddenNearNumber.map{ xy =>
    val amt = counts.get(xy)
    (xy,(amt.toDouble/boardAmount.toDouble))
  }
  val awayProb = (hiddenAwayCount.toDouble/boardAmount.toDouble)/hiddenAway.size.toDouble
  hiddenAway.foreach{ xy => probs = probs.append([(xy,awayProb)])}
  obvsMines.foreach{ xy => probs = probs.append([(xy, 1.0)])}
  println("Found Boards: " ++ foundBoards.show ++ ", " ++ "Valid Boards: " ++ boardAmount.show)
  // println(awayProb)
  // println(hiddenAwayCount.toDouble)
  // println(boardAmount.toDouble)
  // println(hiddenAway.size.toDouble)
  probs
}

def revealObviousMines(board: Board): List[XY] =
  board.getRevealed.collect{ xy =>
    board.getCell(xy) match {
      case SRevealed(c,_) =>
        val hdnbs = board.getHiddenNeighbors(xy)
        if (hdnbs.size == c)
          Some(hdnbs.collect{xy2 => board.removeMine(xy2); Some(xy2)})
        else None()
      case _ => None()
    }
  }.flatMap{e => e}