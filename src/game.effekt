module src/game

import src/utils

effect Reveal(cell: (Int,Int)): Unit
effect GameOver(): Unit
effect Flag(cell: (Int,Int)): Unit

// for resuming with each value with each()

def initializeBoard(rows: Int, cols: Int, mines: Int): Board = {
  var cells: List[XY] = empty()
  try {
    val x = do Offset(0, rows)
    val y = do Offset(0, cols)
    cells = cells.append([XY(x,y)])
  } with Offset {(s,e) =>
    each(s,e) {v => resume(v)}
  }
  while (cells.size() > mines) {
    // ?+1 so we can also hit the last cell?
    val idx = (random() * (cells.size() + 1).toDouble()).floor()
    cells = cells.deleteAt(idx)
  }
  return buildBoard(rows, cols, cells)
}

def flagCell(board: Board, xy: XY): Board / {} = {
  val cell = board.getCell(xy)
  cell match {
    case Hidden(hasMine, isFlagged) =>
      board.setCell(xy, Hidden(hasMine, not(isFlagged)))
    case Revealed(_) =>
      println("Cannot flag a revealed cell!")
    case _ => <>
  }
  board
}

def revealCell(board: Board, xy: XY): Unit / {GameOver} = {
  val cell = board.getCell(xy)
  cell match {
    case Hidden(hasMine, _) =>
      if (hasMine) do GameOver()
      else {
        val adjMines = countAdjacentMines(board, xy)
        board.setCell(xy, Revealed(adjMines))
        if (adjMines == 0) revealAdjacentCells(board, xy)
      }
    case _ => ()
  }
}

def countAdjacentMines(board: Board, xy: XY): Int = {
  var counter = 0
  board.getNeighbors(xy, 1).foreach{cel =>
    if (board.getCell(cel) is Hidden(true, _)) counter = counter + 1
  }
  counter
}

def getNeighbors(board: Board, xy: XY, size: Int): List[XY] = {
  var list: List[XY] = empty()
  try {
    val dr = do Offset(0 - size, size + 1)
    val dc = do Offset(0 - size, size + 1)
    val nr = xy.y + dr
    val nc = xy.x + dc
    if ((nr >= 0 && nr < board.rows && nc >= 0 && nc < board.cols) and not(equals((dc,dr),(0,0))))
      list = Cons(XY(nc,nr),list)
  } with Offset {(s,e) =>
    each(s,e){v => resume(v)}
  }
  list.reverse
}

def getRevealedNeighbors(board: Board, xy: XY): List[XY] = {
  board.getNeighbors(xy, 1).collect{ xy =>
    board.getCell(xy) match {
      case Revealed(_) => Some(xy)
      case _ => None()
    }
  }
}

def revealAdjacentCells(board: Board, xy: XY): Unit / {GameOver} = {
  board.getNeighbors(xy, 1).foreach{ xy => board.revealCell(xy) }
}