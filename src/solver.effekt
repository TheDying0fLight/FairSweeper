import src/game

effect QuickMoves(moves: List[XY]): Unit

def solve(board: Board): List[XY] / {QuickMoves} = {
  var board = board
  var amt_mines = board.mines
  var found_bomb = true
  var numbers = board.collectWithXY() {
    case Revealed(count) and count > 0 => true
    case _ => false
  }

  while (found_bomb and amt_mines > 0) {
    found_bomb = false
    numbers = numbers.map() {
      case (xy, _) => (xy, board.getCell(xy))
    }
    numbers.foreach() {
      case (xy, Revealed(count)) =>
        val unrvNeighbors = board.unrevealedNeighbors(xy)
        if (unrvNeighbors.size() == count) unrvNeighbors.foreach() {
          xy => board = board.removeMine(xy)
          amt_mines = amt_mines - 1
          found_bomb = true
        }
      case _ => ()
    }
  }

  var moves: List[XY] = empty()
  numbers = numbers.collect() {
    case (xy, Revealed(count)) and count > 0 => Some((xy, Revealed(count)))
    case (xy, _) =>
      val unrvNeighbors = board.unrevealedNeighbors(xy)
      moves = moves.append(unrvNeighbors)
      None()
  }
  do QuickMoves(moves)

  // if number is larger and has same neighbors except difference then non shared neighbors are bombs
  numbers.foreach() {
    case (xy, Revealed(count)) =>
      val neighbors = board.neighbors(xy)
      neighbors.foreach() {xy =>
        board.getCell(xy)
        <>
      }
    case _ => ()
  }
  moves
}

def getIntersection(l1: List[XY], l2: List[XY]): List[XY] = {
  l1.collect() {xy1 =>
    if (l2.any() {xy2 => xy2 == xy1}) Some(xy1)
    else None()
  }
}

def getDifference(l1: List[XY], l2: List[XY]): List[XY] = {
  var diff: List[XY] = empty()
  val intersection = l1.getIntersection(l2)
  l1.collect() {xyl =>
    if (not(intersection.any() {xyi => xyi == xyl})) Some(xyl)
    else None()
  }
}

def unrevealedNeighbors(board: Board, xy: XY): List[XY] = {
  board.neighbors(xy).collect() {xy =>
    board.getCell(xy) match {
      case Hidden(_, _) => Some(xy)
      case _ => None()
    }
  }
}

def removeMine(board: Board, xy: XY): Board = {
  board.setCell(xy, Revealed(0))
  board.neighbors(xy).foreach() {xy =>
    board.getCell(xy) match {
      case Revealed(count) => board.setCell(xy, Revealed(count - 1))
      case _ => ()
    }
  }
  board
}