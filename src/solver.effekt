import src/game

effect QuickMoves(moves: List[XY]): Unit

def getMoves(board: Board): List[XY] / {QuickMoves} = {
  var board = board
  var amtMines = board.mines
  var madeProgress = true
  var foundMines: List[XY] = empty()
  var moves: List[XY] = empty()
  var numbers = board.getXY{
    case Revealed(count) and count > 0 => true
    case _ => false
  }
  def remMines(mines: List[XY]) = {
    amtMines = amtMines - mines.size()
    foundMines = foundMines.append(mines)
    madeProgress = true
    board.removeMines(mines)
  }
  def updateNumbers() = {
    numbers = numbers.collect{ xy =>
      val count = if (board.getCell(xy) is Revealed(c)) c else 0
      count match {
        case 0 =>
          val hiddenNeighbors = board.hiddenNeighbors(xy)
          moves = moves.append(hiddenNeighbors)
          None()
        case v => if (v > 0) Some(xy) else None()
      }
    }
  }

  while (madeProgress and amtMines > 0) {
    madeProgress = false
    // simple solving
    numbers.foreach{ xy =>
      val hiddenNeighbors = board.hiddenNeighbors(xy)
      val count = if (board.getCell(xy) is Revealed(c)) c else 0
      if (hiddenNeighbors.size() == count) remMines(hiddenNeighbors)
    }
    updateNumbers()

    do QuickMoves(moves)
    // advanced solving
    numbers.foreach{ xy =>
      val mines = board.findMinesByDifference(xy)
      if (mines.size() > 0) remMines(mines)
    }
    updateNumbers()

    // if nbs cell1 are subset nbs cell2 and cell1.count == cell2.count difference is safe
    numbers.foreach{ xy =>
      val new_moves = board.findMovesBySubset(xy)
      if (new_moves.size > 0) {
        moves = moves.append(new_moves)
        new_moves.foreach{ move =>
          board.setCell(move, Revealed(-1))
        }
        madeProgress = true
      }
    }
  }

  if (amtMines == 0) {
    moves = empty()
    moves = board.collect{ (xy, cell) =>
      cell match {
        case Hidden(_, _) => Some(xy)
        case Revealed(c) and c < 0 => Some(xy)
        case _ => None()
      }
    }
  }
  moves
}

def checkByHiddenNeighbors(board: Board, xy: XY) {f: ((List[XY], Int), (List[XY], Int)) => List[XY]}: List[XY] = {
  val count = if (board.getCell(xy) is Revealed(c)) c else 0
  val nbs = board.neighbors(xy)
  val hdnbs = board.hiddenNeighbors(xy)
  var acc: List[XY] = empty()
  nbs.foreach{ xy2 =>
    board.getCell(xy2) match {
      case Revealed(c) and c > count =>
        val hdnbs2 = board.hiddenNeighbors(xy2)
        acc = acc.append(f((hdnbs, count), (hdnbs2, c)))
      case _ => ()
    }
  }
  acc
}

def findMinesByDifference(board: Board, xy: XY): List[XY] = {
  board.checkByHiddenNeighbors(xy) { (a,b) =>
    (a,b) match {
      case ((hdnbs, count), (hdnbs2, count2)) =>
        val diff = getDifference(hdnbs2, hdnbs)
        if (diff.size() <= count2 - count) diff else Nil()
    }
  }
}

def findMovesBySubset(board: Board, xy: XY): List[XY] = {
  board.checkByHiddenNeighbors(xy) { (a,b) =>
    (a,b) match {
      case ((hdnbs, _), (hdnbs2, _)) =>
        if (hdnbs.isSubset(hdnbs2)) {
          val diff = getDifference(hdnbs2, hdnbs)
          diff
        } else Nil()
    }
  }
}

def isSubset(subset: List[XY], set: List[XY]): Bool = {
  subset.all{ xy =>
    set.any{xy2 => xy == xy2}
  }
}

def getIntersection(l1: List[XY], l2: List[XY]): List[XY] = {
  l1.collect{xy1 =>
    if (l2.any{xy2 => xy2 == xy1}) Some(xy1)
    else None()
  }
}

def getDifference(l1: List[XY], l2: List[XY]): List[XY] = {
  var diff: List[XY] = empty()
  val intersection = l1.getIntersection(l2)
  l1.collect{xyl =>
    if (not(intersection.any{xyi => xyi == xyl})) Some(xyl)
    else None()
  }
}

def hiddenNeighbors(board: Board, xy: XY): List[XY] = {
  board.neighbors(xy).collect{ xy =>
    board.getCell(xy) match {
      case Hidden(_, _) => Some(xy)
      case _ => None()
    }
  }
}

def removeMine(board: Board, mine: XY): Unit = {
  board.setCell(mine, Revealed(0))
  board.neighbors(mine).foreach{ xy =>
    board.getCell(xy) match {
      case Revealed(count) => board.setCell(xy, Revealed(count - 1))
      case _ => ()
    }
  }
}

def removeMines(board: Board, mines: List[XY]): Unit = {
  mines.foreach{ xy => board.removeMine(xy) }
}