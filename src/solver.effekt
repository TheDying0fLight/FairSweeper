import src/game
import src/utils

effect QuickMoves(moves: List[XY]): Unit

def getMoves(board: Board, foundMoves: List[XY], foundMines: List[XY]): List[XY] / {QuickMoves} = {
  var board = board
  var amtMines = board.mines
  var madeProgress = true
  var foundMines = foundMines
  board.removeMines(foundMines)
  var moves = foundMoves
  board.removeMoves(foundMoves)
  var numbers = board.getXY{
    case Revealed(count) and count > 0 => true
    case _ => false
  }
  def remMines(mines: List[XY]) = {
    amtMines = amtMines - mines.size()
    foundMines = foundMines.append(mines)
    madeProgress = true
    board.removeMines(mines)
  }
  def updateNumbers() = {
    numbers = numbers.collect{ xy =>
      val count = if (board.getCell(xy) is Revealed(c)) c else <>
      count match {
        case 0 =>
          val hiddenNeighbors = board.hiddenNeighbors(xy)
          moves = moves.append(hiddenNeighbors)
          board.removeMoves(hiddenNeighbors)
          None()
        case v => if (v > 0) Some(xy) else None()
      }
    }
  }

  while (madeProgress and amtMines > 0) {
    madeProgress = false
    // solve via hidden == count
    numbers.foreach{ xy =>
      val hiddenNeighbors = board.hiddenNeighbors(xy)
      val count = if (board.getCell(xy) is Revealed(c)) c else <>
      if (hiddenNeighbors.size() == count) remMines(hiddenNeighbors)
    }
    updateNumbers()

    do QuickMoves(moves)
    // solve via bomb difference
    numbers.foreach{ xy =>
      val mines = board.findMinesByDifference(xy)
      if (mines.size() > 0) {remMines(mines)}
    }
    updateNumbers()

    // solve via subset
    numbers.foreach{ xy =>
      val newMoves = board.findMovesBySubset(xy)
      if (newMoves.size > 0) {
        moves = moves.append(newMoves)
        board.removeMoves(newMoves)
        madeProgress = true
      }
    }
  }
  // if all bombs found other fields must be save
  if (amtMines == 0) {
    board.foreach{ (xy,cell) =>
      cell match {
        case Hidden(_,_) => moves = moves.append(Cons(xy,Nil()))
        case _ => ()
      }
    }
  }
  moves
}

def findMinesByDifference(board: Board, xy: XY): List[XY] = {
  board.checkByHiddenNeighbors(xy) { (a,b) =>
    (a,b) match {
      case ((hdnbs, count), (hdnbs2, count2)) and count2 > count =>
        val diff = getDifference(hdnbs2, hdnbs)
        if (diff.size() <= count2 - count) diff else Nil()
      case _ => Nil()
    }
  }
}

def findMovesBySubset(board: Board, xy: XY): List[XY] = {
  board.checkByHiddenNeighbors(xy) { (a,b) =>
    (a,b) match {
      case ((hdnbs, _), (hdnbs2, _)) =>
        if (hdnbs.isSubset(hdnbs2)) getDifference(hdnbs2, hdnbs)
        else Nil()
    }
  }
}

def checkByHiddenNeighbors(board: Board, xy: XY) {f: ((List[XY], Int), (List[XY], Int)) => List[XY]}: List[XY] = {
  val count = if (board.getCell(xy) is Revealed(c)) c else 0
  val nbs = board.neighbors(xy)
  val hdnbs = board.hiddenNeighbors(xy)
  var acc: List[XY] = empty()
  nbs.foreach{ xy2 =>
    board.getCell(xy2) match {
      case Revealed(count2) and count2 > 0 =>
        val hdnbs2 = board.hiddenNeighbors(xy2)
        acc = acc.append(f((hdnbs, count), (hdnbs2, count2)))
      case _ => ()
    }
  }
  acc
}

def isSubset(subset: List[XY], set: List[XY]): Bool = {
  subset.all{ xy =>
    set.any{xy2 => xy == xy2}
  }
}

def getIntersection(l1: List[XY], l2: List[XY]): List[XY] = {
  l1.collect{xy1 =>
    if (l2.any{xy2 => xy2 == xy1}) Some(xy1)
    else None()
  }
}

def getDifference(list: List[XY], without: List[XY]): List[XY] = {
  var diff: List[XY] = empty()
  val intersection = list.getIntersection(without)
  list.collect{xyl =>
    if (not(intersection.any{xyi => xyi == xyl})) Some(xyl)
    else None()
  }
}

def hiddenNeighbors(board: Board, xy: XY): List[XY] = {
  board.neighbors(xy).collect{ xy =>
    board.getCell(xy) match {
      case Hidden(_, _) => Some(xy)
      case _ => None()
    }
  }
}

def removeMine(board: Board, mine: XY): Unit = {
  board.setCell(mine, Revealed(0))
  board.neighbors(mine).foreach{ xy =>
    board.getCell(xy) match {
      case Revealed(count) => board.setCell(xy, Revealed(count - 1))
      case _ => ()
    }
  }
}

def removeMines(board: Board, mines: List[XY]): Unit = {
  mines.foreach{ xy => board.removeMine(xy) }
}

def removeMoves(board: Board, moves: List[XY]): Unit = {
  moves.foreach{xy => board.setCell(xy, Revealed(-1))}
}