import src/game

effect QuickMoves(moves: List[XY]): Unit

def getMoves(board: Board): List[XY] / {QuickMoves} = {
  var board = board
  var amt_mines = board.mines
  var found_bomb = true
  var numbers = board.collectWithXY() {
    case Revealed(count) and count > 0 => true
    case _ => false
  }

  while (found_bomb and amt_mines > 0) {
    found_bomb = false
    numbers = numbers.map() {
      case (xy, _) => (xy, board.getCell(xy))
    }
    numbers.foreach() {
      case (xy, Revealed(count)) =>
        val unrvNeighbors = board.unrevealedNeighbors(xy)
        if (unrvNeighbors.size() == count) unrvNeighbors.foreach() {
          xy => board.removeMine(xy)
          amt_mines = amt_mines - 1
          found_bomb = true
        }
      case _ => ()
    }
  }

  var moves: List[XY] = empty()
  numbers = numbers.collect() {
    case (xy, Revealed(count)) and count > 0 => Some((xy, Revealed(count)))
    case (xy, _) =>
      val unrvNeighbors = board.unrevealedNeighbors(xy)
      moves = moves.append(unrvNeighbors)
      None()
  }
  do QuickMoves(moves)

  // if number is larger and has same neighbors except difference then non shared neighbors are bombs
  while (found_bomb and amt_mines > 0) {
    numbers.foreach() {
      case (xy, _) =>
        val mines = board.detectNbMinesByDifference(xy)
        board.removeMines(mines)
        ()
    }
  }
  moves
}

def detectNbMinesByDifference(board: Board, xy: XY): List[XY] = {
  val count = if (board.getCell(xy) is Revealed(c)) c else 0
  var mines: List[XY] = empty()
  val nb = board.neighbors(xy)
  nb.foreach() { xy2 =>
    val comp_cell = board.getCell(xy2)
    comp_cell match {
      case Revealed(c) and c > count =>
        val nb2 = board.neighbors(xy2)
        val diff = nb2.getDifference(nb)
        if (diff.size() <= c - count) mines = mines.append(diff)
      case _ => ()
    }
  }
  mines
}

def getIntersection(l1: List[XY], l2: List[XY]): List[XY] = {
  l1.collect() {xy1 =>
    if (l2.any() {xy2 => xy2 == xy1}) Some(xy1)
    else None()
  }
}

def getDifference(l1: List[XY], l2: List[XY]): List[XY] = {
  var diff: List[XY] = empty()
  val intersection = l1.getIntersection(l2)
  l1.collect() {xyl =>
    if (not(intersection.any() {xyi => xyi == xyl})) Some(xyl)
    else None()
  }
}

def unrevealedNeighbors(board: Board, xy: XY): List[XY] = {
  board.neighbors(xy).collect() { xy =>
    board.getCell(xy) match {
      case Hidden(_, _) => Some(xy)
      case _ => None()
    }
  }
}

def removeMine(board: Board, mine: XY): Unit = {
  board.setCell(mine, Revealed(0))
  board.neighbors(mine).foreach() { xy =>
    board.getCell(xy) match {
      case Revealed(count) => board.setCell(xy, Revealed(count - 1))
      case _ => ()
    }
  }
}

def removeMines(board: Board, mines: List[XY]): Unit = {
  mines.foreach() {xy =>
    board.removeMine(xy)
  }
}