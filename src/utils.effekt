// -------------------------- Other ----------------------------
effect Offset(start: Int, end: Int): Int
effect Return[A](v: A): Unit

// -------------------------- Cell ------------------------------
type Cell {
  Hidden(hasMine: Bool, isFlagged: Bool)
  Revealed(adjacentMines: Int)
  // Helper for solver
  TrueHidden()
  Mine()
  NoMine()
}

def infixEq(left: Cell, right: Cell): Bool =
  if (left is Hidden(l1, l2) and right is Hidden(r1, r2)) {
    l1 == r1 && l2 == r2
  } else if (left is Revealed(a) and right is Revealed(b)) {
    a == b
  } else false

// --------------------------- XY --------------------------------
record XY(x: Int, y: Int)

def infixEq(left: XY, right: XY): Bool =
  if (left is XY(x1, y1) and right is XY(x2, y2)) {
    x1 == x2 && y1 == y2
  } else false

def infixEq(left: List[XY], right: List[XY]): Bool = {
  with on[OutOfBounds].default{false}
  var v = left.size == right.size
  left.foreachIndex{ (idx,xy){ctrl} =>
    if (not(v)) ctrl.break()
    v = (xy == right.get(idx))
  }
  v
}

def removeDuplicates(list: List[XY]) =
  list.foldRight(Nil()){(nw,acc) =>
    if (acc.any{old => equals(nw, old)}) acc
    else acc.append(Cons(nw,Nil()))
  }

def show(xy: XY): String = "(" ++ xy.x.show ++ "," ++ xy.y.show ++ ")"

def println(xys: List[XY]): Unit = {
  xys.foreach{xy => println(xy.show)}
}

// ----------------------- CellDict ---------------------------
record CellDict(items: List[(XY,Int)])

def get(dict: CellDict, key: XY): Int = {
  try {
    dict.items.foreach{ case (k,v) =>
      if (k == key) do Return(v)
    }
    0
  } with Return[Int] {v => v}
}

def set(dict: CellDict, key: XY, newV: Int): CellDict = {
  var found = false
  var items = dict.items.map{case (k,v) =>
    if (k == key) {found = true; (k,newV)}
    else (k,v)
  }
  if (not(found)) items = items.append([(key,newV)])
  CellDict(items)
}

// -------------------------- Board -----------------------------------
record Board(grid: Array[Array[Cell]], rows: Int, cols: Int, mines: Int)

def getCell(board: Board, xy: XY): Cell = {
  with on[OutOfBounds].panic
  return board.grid.get(xy.y).get(xy.x)
}

def setCell(board: Board, xy: XY, new_val: Cell): Unit = {
  with on[OutOfBounds].panic
  board.grid.get(xy.y).set(xy.x, new_val)
}

def buildBoard(rows: Int, cols: Int, mines: List[XY]): Board = {
  with on[OutOfBounds].panic
  var grid: Array[Array[Cell]] = allocate(rows)
  each(0,rows) {rw =>
    grid.set(rw, array(cols, Hidden(false, false)))
  }
  val board = Board(grid, rows, cols, mines.size())
  mines.foreach{cell => board.setCell(cell, Hidden(true, false))}
  return board
}

def getXY(board: Board) {f: Cell => Bool}: List[XY] = {
  board.collect{ (xy, cell) =>
    if (f(cell)) Some(xy)
    else None()
  }
}

def foreach(board: Board) {f: (XY, Cell) => Unit}: Unit = {
  try {
    val x = do Offset(0, board.cols)
    val y = do Offset(0, board.rows)
    val xy = XY(x,y)
    val cell = board.getCell(xy)
    f(xy, cell)
  } with Offset {(s,e) =>
    each(s,e) {v => resume(v)}
  }
}

def collect[A](board: Board) {f: (XY, Cell) => Option[A]}: List[A] = {
  var acc: List[A] = empty()
  board.foreach{ (a,b) =>
    f(a,b) match {
      case Some(v) => acc = Cons(v,acc)
      case None()  => ()
    }
  }
  acc.reverse
}

def copy(board: Board): Board = {
  with on[OutOfBounds].panic
  var newGrid = board.grid.copy
  newGrid.foreachIndex{ (index,row) =>
    newGrid.set(index,row.copy)
  }
  Board(newGrid, board.rows, board.cols, board.mines)
}

def hideHiddenInfo(board: Board): Unit =
  board.foreach{ (xy,cell) =>
    board.getCell(xy) match {
      case Hidden(_,_) => board.setCell(xy, TrueHidden())
      case _ => ()
    }
  }